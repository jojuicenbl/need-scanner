"""Pydantic models for data validation and structure."""

from pydantic import BaseModel, HttpUrl
from typing import Optional, List, Any, Literal


class Post(BaseModel):
    """A post from any source (multi-source support)."""
    id: str  # Prefixed with source: hn_123, x_abc, reddit_xyz
    source: Literal["reddit", "hn", "rss", "x", "ph", "se", "appstore", "play"] = "reddit"
    title: str
    body: str = ""  # Renamed from selftext for consistency
    created_ts: Optional[float] = None  # Renamed from created_utc
    url: Optional[str] = None  # Renamed from permalink
    score: Optional[int] = 0
    comments_count: Optional[int] = 0  # Renamed from num_comments
    lang: Optional[str] = None  # Language detected (en, fr, etc.)
    intent: Optional[str] = None  # pain, request, howto, promo, news, other
    wtp_signals: Optional[dict] = None  # Willingness-to-pay signal detection results
    raw: dict

    # Backward compatibility aliases
    @property
    def selftext(self) -> str:
        return self.body

    @property
    def created_utc(self) -> Optional[float]:
        return self.created_ts

    @property
    def permalink(self) -> Optional[str]:
        return self.url

    @property
    def num_comments(self) -> Optional[int]:
        return self.comments_count


class EnrichedClusterSummary(BaseModel):
    """Enhanced summary with deep market analysis."""
    cluster_id: int
    size: int
    title: str
    problem: str  # Renamed from description for clarity
    persona: str  # Target persona (freelancer, ecom owner, SMB, dev, etc.)
    jtbd: str  # Job-To-Be-Done format: "Quand [situation], je veux [progrès], afin de [résultat]"
    context: str  # Current tools, constraints, frequency
    monetizable: bool
    mvp: str
    alternatives: List[str] = []  # Existing solutions mentioned
    willingness_to_pay_signal: str = ""  # Evidence of WTP
    pain_score_llm: Optional[int] = None
    sector: Optional[str] = None  # Sector classification (dev_tools, business_pme, etc.)

    # Backward compatibility
    @property
    def description(self) -> str:
        return self.problem

    @property
    def justification(self) -> str:
        return f"Persona: {self.persona}. Context: {self.context}"


# Keep old ClusterSummary for backward compatibility
class ClusterSummary(BaseModel):
    """Summary of a cluster generated by LLM (legacy format)."""
    cluster_id: int
    size: int
    title: str
    description: str
    monetizable: bool
    justification: str
    mvp: str
    pain_score_llm: Optional[int] = None


class EnrichedInsight(BaseModel):
    """Complete insight with enriched analysis and priority scoring."""
    cluster_id: int
    rank: int  # Priority ranking
    priority_score: float  # Final priority score (0-10)
    priority_score_adjusted: Optional[float] = None  # Priority score adjusted with history penalty
    mmr_rank: Optional[int] = None  # Rank after MMR reranking
    examples: List[dict]  # subset of meta (id, url, score, comments_count, source)
    summary: EnrichedClusterSummary
    pain_score_final: Optional[int] = None  # Combined LLM + heuristic
    heuristic_score: Optional[float] = None
    traction_score: Optional[float] = None
    novelty_score: Optional[float] = None
    trend_score: Optional[float] = None  # Market trend score (LLM + historical growth)
    founder_fit_score: Optional[float] = None  # Founder fit score (1-10)
    keywords_matched: List[str] = []  # Keywords that triggered inclusion
    source_mix: List[str] = []  # List of sources in this cluster

    # Inter-day deduplication (Step 5.1)
    max_similarity_with_history: Optional[float] = None  # Max cosine similarity with historical insights
    duplicate_of_insight_id: Optional[str] = None  # ID of the most similar historical insight
    is_historical_duplicate: bool = False  # True if similarity >= threshold

    # SaaS-ability / Productizability (Step 5.2)
    solution_type: Optional[str] = None  # saas_b2b, saas_b2c, tooling_dev, api_product, service_only, content_only, hardware_required, regulation_policy, impractical_unclear
    recurring_revenue_potential: Optional[float] = None  # 1-10 scale
    saas_viable: Optional[bool] = None  # True if SaaS-exploitable by indie dev

    # Product Ideation (Step 5.3)
    product_angle_title: Optional[str] = None  # Short title for the product opportunity
    product_angle_summary: Optional[str] = None  # Description of the product angle
    product_angle_type: Optional[str] = None  # indie_saas, b2b_saas, plugin, api, etc.
    product_pricing_hint: Optional[str] = None  # Pricing range suggestion
    product_complexity: Optional[int] = None  # 1-3 scale for solo dev


class Insight(BaseModel):
    """Complete insight for a cluster with examples and summary (legacy format)."""
    cluster_id: int
    examples: List[dict]  # subset of meta (id, url, score, num_comments)
    summary: ClusterSummary
    pain_score_final: Optional[int] = None  # Combined LLM + heuristic score


class ProcessingStats(BaseModel):
    """Statistics from the processing pipeline."""
    total_posts: int
    after_cleaning: int
    after_dedup: int
    num_clusters: int
    embeddings_cost_usd: float = 0.0
    summary_cost_usd: float = 0.0
    total_cost_usd: float = 0.0
