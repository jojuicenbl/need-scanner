"""Pydantic models for data validation and structure."""

from pydantic import BaseModel, HttpUrl
from typing import Optional, List, Any, Literal


class Post(BaseModel):
    """A post from any source (multi-source support)."""
    id: str  # Prefixed with source: hn_123, x_abc, reddit_xyz
    source: Literal["reddit", "hn", "rss", "x", "ph", "se", "appstore", "play"] = "reddit"
    title: str
    body: str = ""  # Renamed from selftext for consistency
    created_ts: Optional[float] = None  # Renamed from created_utc
    url: Optional[str] = None  # Renamed from permalink
    score: Optional[int] = 0
    comments_count: Optional[int] = 0  # Renamed from num_comments
    lang: Optional[str] = None  # Language detected (en, fr, etc.)
    intent: Optional[str] = None  # pain, request, howto, promo, news, other
    wtp_signals: Optional[dict] = None  # Willingness-to-pay signal detection results
    raw: dict

    # Backward compatibility aliases
    @property
    def selftext(self) -> str:
        return self.body

    @property
    def created_utc(self) -> Optional[float]:
        return self.created_ts

    @property
    def permalink(self) -> Optional[str]:
        return self.url

    @property
    def num_comments(self) -> Optional[int]:
        return self.comments_count


class EnrichedClusterSummary(BaseModel):
    """Enhanced summary with deep market analysis."""
    cluster_id: int
    size: int
    title: str
    problem: str  # Renamed from description for clarity
    persona: str  # Target persona (freelancer, ecom owner, SMB, dev, etc.)
    jtbd: str  # Job-To-Be-Done format: "Quand [situation], je veux [progrès], afin de [résultat]"
    context: str  # Current tools, constraints, frequency
    monetizable: bool
    mvp: str
    alternatives: List[str] = []  # Existing solutions mentioned
    willingness_to_pay_signal: str = ""  # Evidence of WTP
    pain_score_llm: Optional[int] = None

    # Backward compatibility
    @property
    def description(self) -> str:
        return self.problem

    @property
    def justification(self) -> str:
        return f"Persona: {self.persona}. Context: {self.context}"


# Keep old ClusterSummary for backward compatibility
class ClusterSummary(BaseModel):
    """Summary of a cluster generated by LLM (legacy format)."""
    cluster_id: int
    size: int
    title: str
    description: str
    monetizable: bool
    justification: str
    mvp: str
    pain_score_llm: Optional[int] = None


class EnrichedInsight(BaseModel):
    """Complete insight with enriched analysis and priority scoring."""
    cluster_id: int
    rank: int  # Priority ranking
    priority_score: float  # Final priority score (0-10)
    examples: List[dict]  # subset of meta (id, url, score, comments_count, source)
    summary: EnrichedClusterSummary
    pain_score_final: Optional[int] = None  # Combined LLM + heuristic
    heuristic_score: Optional[float] = None
    traction_score: Optional[float] = None
    novelty_score: Optional[float] = None
    trend_score: Optional[float] = None  # Week-over-week growth score
    keywords_matched: List[str] = []  # Keywords that triggered inclusion
    source_mix: List[str] = []  # List of sources in this cluster


class Insight(BaseModel):
    """Complete insight for a cluster with examples and summary (legacy format)."""
    cluster_id: int
    examples: List[dict]  # subset of meta (id, url, score, num_comments)
    summary: ClusterSummary
    pain_score_final: Optional[int] = None  # Combined LLM + heuristic score


class ProcessingStats(BaseModel):
    """Statistics from the processing pipeline."""
    total_posts: int
    after_cleaning: int
    after_dedup: int
    num_clusters: int
    embeddings_cost_usd: float = 0.0
    summary_cost_usd: float = 0.0
    total_cost_usd: float = 0.0
